#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <malloc.h>


//Даны m наборов, каждый из которых состоит из n чисел. В каждом наборе можно переставлять цифры произвольным образом, получая при этом некоторое число.Необходимо проверить, можно
//ли сформировать из этих наборов возрастающую последовательность чисел


// Функция для сортировки цифр в числе
void sortDigits(int* num, int n) 
{
	for (int i = 0; i < n - 1; i++) 
	{
		for (int j = 0; j < n - i - 1; j++) 
		{
			if (num[j] > num[j + 1]) 
			{
				int temp = num[j];
				num[j] = num[j + 1];
				num[j + 1] = temp;
			}
		}
	}
}

// Функция для проверки, можно ли сформировать возрастающую последовательность
bool canFormIncreasingSequence(int** sets, int m, int n) 
{
	// Сортируем цифры внутри каждого числа в каждом наборе
	for (int i = 0; i < m; i++) 
	{
		sortDigits(sets[i], n);
	}

	// Инициализируем первое число как минимальное из первых чисел в наборах
	int currentMin = sets[0][0];

	// Проверяем, можно ли объединить отсортированные наборы в последовательность
	for (int i = 1; i < m; i++) 
	{
		int j = 0;
		while (j < n && sets[i][j] <= currentMin) 
		{
			j++;
		}
		if (j == n)
		{
			return false; // Нельзя сформировать возрастающую последовательность
		}
		currentMin = sets[i][j];
	}

	return true; // Можно сформировать возрастающую последовательность
}

int main() 
{
	system("chcp 1251");
	int m, n;

	do {
		printf("Введите количество наборов (m): "); scanf("%d", &m);
	} while (m<2);

	do {
		printf("Введите количество чисел в каждом наборе (n): "); scanf("%d", &n);
	} while (n<2);

	int** sets = (int**)malloc(m * sizeof(int*));

	for (int i = 0; i < m; i++) 
	{
		printf("Введите числа набора %d:\n", i+1);
		sets[i] = (int*)malloc(n * sizeof(int));
		for (int j = 0; j < n; j++) 
		{
			scanf("%d", &sets[i][j]);
		}
	}

	if (canFormIncreasingSequence(sets, m, n)) {
		printf("Можно сформировать возрастающую последовательность.\n");
	}
	else {
		printf("Нельзя сформировать возрастающую последовательность.\n");
	}

	// Освобождаем выделенную память
	for (int i = 0; i < m; i++) {
		free(sets[i]);
	}
	free(sets);

	return 0;
}
//Сортировка цифр внутри каждого числа в каждом наборе: Этот шаг включает в себя два вложенных цикла, где n - количество чисел в каждом наборе. 
//Поэтому сложность этого шага составляет O(m * n^2), где m - количество наборов, а n - количество чисел в каждом наборе.
//Проверка на возможность формирования возрастающей последовательности : Этот шаг включает в себя один внешний цикл, который перебирает все наборы.
//Внутри этого цикла выполняется еще один цикл, который перебирает числа внутри набора.Сложность этого шага составляет O(m* n), 
//где m - количество наборов, а n - количество чисел в каждом наборе.
//Итоговая сложность алгоритма : O(m * n ^ 2 + m * n).
//Алгоритм имеет квадратичную сложность(O(n ^ 2)) от количества чисел внутри каждого набора и линейную сложность(O(m)) от количества наборов.
